From: Jason Rhinelander <jason@imaginary.ca>
Date: Fri, 15 Sep 2023 15:51:04 -0300
Subject: epoll: always retrieve events from triggered sockets

The epoll approach sometimes hangs sockets: apparently the call to
getting the ZMQ events off a socket has internal ZMQ side effects (see
libzmq issue 3641 for more), so make sure we always call it on triggered
sockets when using epoll.
---
 oxenmq/proxy.cpp | 24 ++++++++++++++++--------
 1 file changed, 16 insertions(+), 8 deletions(-)

diff --git a/oxenmq/proxy.cpp b/oxenmq/proxy.cpp
index 8d4df9d..ef9cee2 100644
--- a/oxenmq/proxy.cpp
+++ b/oxenmq/proxy.cpp
@@ -547,15 +547,20 @@ void OxenMQ::proxy_loop(std::promise<void> startup) {
 
             queue.clear();
             for (int i = 0; i < max; i++) {
+                // Querying the zmq events here is required as it has side effects of processing
+                // things on the socket that isn't done by just trying to read off the socket below;
+                // see https://github.com/zeromq/libzmq/issues/3641 for details.
                 const auto conn_id = evs[i].data.u64;
                 if (conn_id == EPOLL_COMMAND_ID)
-                    process_control = true;
+                    process_control = command.get(zmq::sockopt::events) & ZMQ_POLLIN;
                 else if (conn_id == EPOLL_WORKER_ID)
-                    process_worker = true;
+                    process_worker = workers_socket.get(zmq::sockopt::events) & ZMQ_POLLIN;
                 else if (conn_id == EPOLL_ZAP_ID)
-                    process_zap = true;
-                else if (auto it = connections.find(conn_id); it != connections.end())
-                    queue.push_back(&*it);
+                    process_zap = zap_auth.get(zmq::sockopt::events) & ZMQ_POLLIN;
+                else if (auto it = connections.find(conn_id); it != connections.end()) {
+                    if (it->second.get(zmq::sockopt::events) & ZMQ_POLLIN)
+                        queue.push_back(&*it);
+                }
             }
             queue.push_back(nullptr);
         }
@@ -608,10 +613,13 @@ void OxenMQ::proxy_loop(std::promise<void> startup) {
         OMQ_TRACE("processing new incoming messages");
         if (process_all) {
             queue.resize(connections.size() + 1);
-            int i = 0;
+            size_t i = 0;
             for (auto& id_sock : connections)
-                queue[i++] = &id_sock;
-            queue[i] = nullptr;
+                if (id_sock.second.get(zmq::sockopt::events) & ZMQ_POLLIN)
+                    queue[i++] = &id_sock;
+            queue[i++] = nullptr;
+            if (queue.size() > i)
+                queue.resize(i);
         }
 
         size_t end = queue.size() - 1;
